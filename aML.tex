%% LyX 2.0.0 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{subscript}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

\makeatother

\usepackage{babel}
\begin{document}

\title{\textbf{aML}\\
Language Reference Manual}


\author{Sriramkumar Balasubramanian (\textbf{sb3457})\\
 Evan Drewry (\textbf{ewd2106})\\
 Timothy Giel (\textbf{tkg2104})\\
 Nikhil Helferty (\textbf{nh2407})}

\maketitle
\pagebreak{}

\tableofcontents{}

\pagebreak{}


\section{Introduction}

This manual describes the aML language which is used for manipulating
mazes and is used to provide instructions to a bot traversing the
maze. \\
The manual provides a reliable guide to using the language. While
it is not the definitive standard, it is meant to be a good interpretation
of how to use the language. This manual follows the general outline
of the reference manual referred to in \textquotedblleft{}The C Programming
Language\textquotedblright{}, but is organized slightly differently
with definitions specific to aML. The grammar in this manual is the
standard for this language.


\section{Lexical Conventions}

A program consists of a single translation unit stored as a file.
There are five classes of tokens: \textbf{identifiers}, \textbf{keywords},
\textbf{constants}, \textbf{operators}, and other separators. White
space (blanks, tabs, newlines, form feeds, etc.) and comments are
ignored except as they separate tokens. Some white space is required
to separate adjacent identifiers, keywords, and constants.


\subsection{Comments}

The characters // introduces a single line comment. The rest of the
line is commented in this case. This differs from a multi-line comment
which is enclosed by the /{*} and {*}/ characters. Multi-line comments
do not nest.


\subsection{Identifiers}

An identifier is a sequence of letters and digits, beginning with
a letter and can be of any length. The case of the letters is relevant
in this case. No other characters can form identifiers. \\
eg. abcd, Abcd, A123,abc1


\subsection{Keywords}

The following identifiers are reserved for use as keywords, and may
not be used otherwise:-\\
\\
\begin{tabular}{ccccccc}
if & return & display & remove & left & hasleft & Integer\tabularnewline
then & main & print & add & right  & hasright & Boolean\tabularnewline
else & void & source & head & up  & hastop & List<datatype>\tabularnewline
load & function & visited & next & down & hasbottom & Cell\tabularnewline
random & exit & isTarget & isEmpty & CPos &  & \tabularnewline
True & null & NOT & AND &  &  & \tabularnewline
False &  &  & OR &  &  & \tabularnewline
\end{tabular}\\
\\
This language consists of many implicit variables and functions increasing
the size of the reserved words list. 


\subsection{Literals}

There are different kinds of literals (or constants) in aML as listed
below:-


\subsubsection{Integer Literals}

An integer literal is taken to be decimal, and is of data type Integer.
It may consist only of a sequence of digits 0-9. \\
eg. 0,1,22,-5


\subsubsection{Boolean Literals}

A boolean literal is either \textbf{True} or \textbf{False}, and is
of data type Boolean.


\subsubsection{Null}

The null literal has no data type and is simply the word \textbf{null}.
This is linked to the Cell and List<datatype> datatypes which need
to be initialized to some value after declaration.


\subsubsection{List Literals}

The list literal can include either the Integer, Boolean, Cell or
List<datatype> types (cascaded lists). \\
eg. <{[}1{]}>,<{[}1,2,3{]}>,<{[}{[}1,2,3{]},{[}4,5{]}>,<{[}True, False,
True{]}>\\
\\
The Cell datatype does not have any literals associated with it. It
can only be assigned to the CPos variable which will be discussed
in section \ref{sec:Implicit-variables-and}. \\



\subsection{Separators}

The semi-colon \textbf{; }and the pair of braces \textbf{\{ \} },
the < > and {[} {]}, act as separators of the tokens. They are meant
to reduce ambiguity and conflicts during the parsing phase. The semi-colon
is added at the end of every statement to signify the end. The \{
\} are used to collect groups of statements into a single compound
statement block. The < > and {[} {]} are used to instantiate the List<datatype>
variables.


\section{Expressions}

The complete syntax is provided in section \ref{sec:Syntax-summary}.
This section introduces the definition of the expression types which
are the basic building blocks of any language.


\subsection{Primary Expressions}

Primary expressions are identifiers, constants, or expressions in
parentheses. They also include the variable CPos which will be explained
in section \ref{sec:Types-revisited}.\\
\textbf{}\\
\textbf{primary-expression:-}\\
\textbf{\hspace*{0.5cm}identifier}\\
\textbf{\hspace*{0.5cm}literal }\\
\textbf{\hspace*{0.5cm}( expression )}\\
\textbf{\hspace*{0.5cm}(CPos)}\\
 \\
A paranthesized expression is equivalent to the expression without
the parantheses. The parantheses is used to group terms especially
to enforce precedence levels. CPos is the implicit variable denoting
the current position of the bot on the maze. It is mostly used to
assign to variables of Cell datatype.


\subsection{Operators}


\subsubsection{Arithmetic Operators}

There are six arithmetic operators:\{ +, -, {*}, /, \%, \textasciicircum{}\}.
The operands of these operators must be of Integer data type. The
result will also be of type Integer.\\
\textbf{}\\
\textbf{arithmetic-expression:-}\\
\textbf{\hspace*{0.5cm}expression + expression }\\
\textbf{\hspace*{0.5cm}expression - expression }\\
\textbf{\hspace*{0.5cm}expression {*} expression }\\
\textbf{\hspace*{0.5cm}expression / expression }\\
\textbf{\hspace*{0.5cm}expression \% expression }\\
\textbf{\hspace*{0.5cm}expression \textasciicircum{} expression }\\
\\
\begin{tabular}{|c|c|c|}
\hline 
Operator & Semantic & Comments\tabularnewline
\hline 
\hline 
+ & addition & \tabularnewline
\hline 
- & subtraction & \tabularnewline
\hline 
{*} & multiplication & \tabularnewline
\hline 
/ & division & Integer division only. Divide by zero => error\tabularnewline
\hline 
\% & modulo & \tabularnewline
\hline 
\textasciicircum{} & exponentiation & \tabularnewline
\hline 
\end{tabular}\\
\\



\subsubsection{Relational Operators}

The relational operators all return values of Boolean type (either
True or False). There are six relational operators: \{==, \textasciitilde{}=,
>, <, >=, <=\}. The operators all yield \textbf{False} if the specified
relation is false and \textbf{True} if it is true. \\
\textbf{}\\
\textbf{relational-expression:-}\\
\textbf{\hspace*{0.5cm}expression == expression}\\
\textbf{\hspace*{0.5cm}expression \textasciitilde{}= expression}\\
\textbf{\hspace*{0.5cm}expression > expression}\\
\textbf{\hspace*{0.5cm}expression < expression}\\
\textbf{\hspace*{0.5cm} expression >= expression}\\
\textbf{\hspace*{0.5cm}expression <= expression}\\
\\
\begin{tabular}{|c|c|}
\hline 
Operator & Semantic\tabularnewline
\hline 
\hline 
== & equals\tabularnewline
\hline 
\textasciitilde{}= & not equals\tabularnewline
\hline 
> & greater\tabularnewline
\hline 
< & lesser\tabularnewline
\hline 
>= & greater than equals\tabularnewline
\hline 
<= & less than equals\tabularnewline
\hline 
\end{tabular}\\
\\
The \textbf{==} operator compares the value of left expression to
the right expression and evaluates to True if they are equal, False
otherwise. It is vice-versa for the \textbf{\textasciitilde{}= }operator.
The \textbf{> }operator evaluates to true if the left expression is
greater than the right expression, false otherwise. The \textbf{<
}operator behaves in the opposite manner. The \textbf{>= }and \textbf{<=
}operators check for equality condition as well. \\
For the == and \textbf{\textasciitilde{}= }operators, the expressions
involved must be of the same datatype. The other operators are defined
only for the Integer datatype where comparison is meaningful.\\



\subsubsection{Boolean Operators}

The boolean operators all return values of Boolean type (either True
or False). There are three boolean operators: logical-NOT, logical-AND
and logical-OR, denoted by NOT, AND, and OR, respectively. \\
\textbf{}\\
\textbf{Not-expression:-}\\
\textbf{\hspace*{0.5cm}NOT expression}\\
\textbf{And-expression:-}\\
\textbf{\hspace*{0.5cm}expression AND expression}\\
\textbf{Or-expression:-}\\
\textbf{\hspace*{0.5cm}expression OR expression}\\
\\
The operand(s) to NOT, AND and OR have to evaluate to True or False,
or in other words, they must either be Boolean variables or relational
expressions. NOT negates the operand, AND returns True if all operands
evaluate to true, False otherwise. OR returns True if at least one
of the operands evaluate to true, False otherwise.


\subsubsection{Assignment Operators}

There is a single assignment operator in aML, \textbf{:=,} which does
simple assignment. It is a binary operator and it's usage is described
in section\ref{sub:Variable-Initialization}.\\



\subsubsection{Associative Operator}

The \textbf{. }operator is used for function calls on variables represented
by identifiers. The structure of statements involving the operator
is shown in section\ref{sec:Syntax-summary}.


\section{Declarations}

Declarations specify the interpretation given to each identifier i.e.
the type of data it can point to and the associated operations that
go along with it.


\subsection{Variable Declarations\label{sub:Variable-Declarations}}

The data types present are defined as follows:-\\
\textbf{datatype:-}\\
\textbf{\hspace*{0.5cm}Integer}\\
\textbf{\hspace*{0.5cm}Boolean}\\
\textbf{\hspace*{0.5cm}Cell}\\
\textbf{\hspace*{0.5cm}List<datatype>}\\
\\
\\
The rule representing the declaration of variables is listed in the
complete Syntax summary in section \ref{sec:Syntax-summary}. The
declaration of variables is similar to many strongly typed languages
where thet type of the variable must be specified during declaration.
Examples of some variable declarations:-
\begin{itemize}
\item Integer x;
\item Boolean flag;
\item Cell node;
\item List<Integer> myList;
\end{itemize}
Detailed explanation of the List<datatype> and Cell datatypes are
provided in section \ref{sec:Types-revisited}.\\



\subsection{Variable Initialization\label{sub:Variable-Initialization}}

When a variable is declared, an initial value may also be specified
for the identifier being declared.\\
Roughly it is of the form - \textbf{lvalue := rvalue;}\\
 The \textbf{:= }operator is used to set the value of lvalue to the
value of rvalue.
\begin{itemize}
\item x := 10;
\item flag := false;
\item node := null;
\item myList := <{[}1,2,3{]}>;
\end{itemize}
The exact rule is provided in the Syntax summary in section \ref{sec:Syntax-summary}.
Initialization can also be combined with declaration in a single step.
This is also shown in final section.


\subsection{Function Declaration}

Functions can either return a certain datatype or be void functions
(return no value). A function header is specified with the \textbf{function
}keyword and an identifier along with an optional argument list and
return type. Functions can be {}``used'' by function calls. But
for a function to be called, it must be declared in the program.\\
\\
\textbf{function\_declaration:-}\\
\textbf{\hspace*{0.5cm}function\_header \{ body \}}\\
\textbf{}\\
\textbf{function\_header:-}\\
\textbf{\hspace*{0.5cm}function identifier (args\_list\textsubscript{\textbf{opt}})
: ret\_type}\\
\textbf{}\\
\textbf{args\_list:-}\\
\textbf{\hspace*{0.5cm}datatype identifier}\\
\textbf{\hspace*{0.5cm}datatype identifier,args\_list}\\
\textbf{}\\
\textbf{body:-}\\
\textbf{\hspace*{0.5cm}compound-statement}\\
\textbf{}\\
\textbf{}\\
Function calls are handled in section \ref{sec:Syntax-summary}. Compound
statements are described in detail in the section below.\\
\textbf{Note: }The subscript 'opt' stands for optional argument indicating
the term formed by omitting the indicated term is also possible in
the grammar.


\section{Statements}

Statements are usually executed in sequence, with the exception of
conditional statements. They are the next level of basic building
blocks after expressions. Each statement ends with a semi-colon at
the end which denotes the end of the logical statement. The physical
statement which is equivalent to one line in the editor may be comprised
of one or more logical statements.\\
One notable feature in aML is the lack of looping constructs. Iterations
are achieved by tail recursion of functions. The function definition
shown above is represented in the bigger picture in section \ref{sub:Program-Definition}.
The following definition gives an idea about the components of a statement.
The entire definition integrated with other definitions is present
in section \ref{sec:Syntax-summary}.


\subsection{Expression statement}

\textbf{expression-statement:- }\\
\textbf{\hspace*{0.5cm}expression; }\\
Expression statement consist of assignments and function calls. 


\subsection{Compound statements}

Compound statements are provided in the form:-\\
 \textbf{compound-statement:-}\\
\textbf{\hspace*{0.5cm}\{ statement-list \}}\\
\textbf{statement-list:-}\\
\textbf{\hspace*{0.5cm}statement }\\
\textbf{\hspace*{0.5cm}statement statement-list }\\
Compound statements are generally used to form the body of code to
execute in conditional statements, as well as the body of function
definitions.


\subsection{Conditional statements}

Conditional statements have the general form:-\\
 \textbf{conditional-statement:-}\\
\textbf{\hspace*{0.5cm}if (expression) then \{compound-statement\};}\\
\textbf{\hspace*{0.5cm}if (expression) then \{compound-statement\}else
\{compound statement\}}\\
 The else branch is optional. The program will evaluate the expression
in parentheses, and if it evaluates to the Boolean value true then
it executes the corresponding compound-statement, and subsequently
continues on to the statement following the conditional statement.
If the expression does not evaluate to true, then the compound-statement
following the else branch is executed (if it exists). Branches are
evaluated in order, such that only the first branch with an expression
that evaluates to true will be executed, and all others skipped.


\subsection{Return statement}

Return statement Return statements take the form:-\\
\textbf{return-statement:- }\\
\textbf{\hspace*{0.5cm}return expression};\\
The expression should evaluate to a value of the return type of the
function being defined. 


\section{Scope rules}

Programs are not multi-file in AML, so external scope is not a worry.
The lexical scope of identifers is of relevance however. In brief,
subsequent to declaration a given identifier is valid for the rest
of the function inside which it was declared. Re-declarations using
an already declared identifier will overwrite the reference to the
first identifier. No identifiers can be declared outside functions.
\\
While user-defined variables cannot enjoy a global scope, the implicit
variables on the other-hand can do so. More information on implicit
variables is provided in \ref{sec:Implicit-variables-and}.


\section{Preprocessor directives}

Preprocessor directives must precede any code in the program. One
possible preprocessor directive takes the form: \textbf{\#load filename}.
This instruction ensures that the maze to be navigated is to be generated
from the file. The acceptable file format is pre-defined and is independent
of the language used. \\
Another possible directive is: \textbf{\#load-random}. This leads
to the maze is to be randomly generated each time the program runs.
\\
The two directives are mutually exclusive. In the event of multiple
directives, the compiler will show an error. 


\section{Implicit variables and functions\label{sec:Implicit-variables-and}}

aML consists of many implicit variables and functions. The variables
and functions along with their meaing are provided below:-\\



\subsection{Variables}

The implicit variables are as follows.\\

\begin{itemize}
\item CPos - denotes the current position of the bot on the maze. Variables
of type Cell can be instantiated by referencing CPos.
\item Visited - It is a dictionary like structure which maintains the 'visited'
status of each cell of the maze. It is used especially for backtracking
algorithms. It can never be used. The Visit() function provided accesses
this data structure inherently.
\end{itemize}

\subsection{Functions}

The implicit functions mainly deal with the movement and functionalities
of the bot. \\

\begin{itemize}
\item move\_U() - moves the bot one cell up from the current position, returns
true if it succeeds, false otherwise
\item move\_D() - moves the bot one cell down from the current position,
returns true if it succeeds, false otherwise
\item move\_L() - moves the bot one cell left of the current position, returns
true if it succeeds, false otherwise
\item move\_R() - moves the bot one cell right of the current position,
returns true if it succeeds, false otherwise
\item revert() - goes back to the previous position from the current position,
returns true if successful, false if at the start
\item Visit(id) - checks if the cell refered to by id has been visited or
not
\end{itemize}

\section{Types revisited\label{sec:Types-revisited}}

This section discusses the List<datatype> datatype and the functions
associated with it. These two datatypes are in a sense less primitive
than the Integer and Boolean datatypes. They come along with certain
functions which can be applied to variables belonging to these datatypes.
These functions are invoked or called using the \textbf{. }associative
operator on the identifier. The rule regarding the functions is shown
in the final section.


\subsection{List<datatype>}

The List<datatype> from it's definition in section\ref{sub:Variable-Declarations}
allows cascaded lists. This is especially useful for adjacency list
representation of graphs from mazes.\\
The functions associated with the datatype allow the manipulation
and traversal of the lists.\\

\begin{itemize}
\item add() - adds an elements to the end of the current list\\
eg. mylist.add(2);
\item remove() - removes and returns the first element of the current list\\
eg. mylist.remove();
\item isEmpty() - returns true if the current list has no elements, false
otherwise. \\
eg. mylist.isEmpty()
\item head() - returns the first element of the current list\\
eg. mylist.head();
\item next() - returns the tail of the current list. The element next to
the first element of the current list is the head of the tail.\\
eg. mylist.next();
\end{itemize}

\subsection{Cell}

The Cell datatype is unique in the sense that it cannot be set a user-defined
value. At any point of time, a variable of Cell dataype can be assigned
only to the CPos value. It can however be stored in a variable which
will reflect that CPos value then, even if accessed at a later time.
\\
Certain functions are provided for this datatype which makes querying
the cell's content as well as it's neighborhood easier.


\subsubsection{Neighborhood functions}
\begin{itemize}
\item left() - returns the left cell of the current cell if it exists and
the current cell has been visited
\item hasleft() - returns True if there is a cell to the left of the current
cell
\item right() - returns the right cell of the current cell if it exists
and the current cell has been visited
\item hasright() - returns True if there is a cell to the right of the current
cell
\item up() - returns the cell located upwards of the current cell if it
exists and the current cell has been visited
\item hasTop() - returns True if there is a cell to the top of the current
cell
\item down() - returns the cell located downwards of the current cell if
it exists and the current cell has been visited
\item hasbottom() - returns True if there is a cell to the bottom of the
current cell
\end{itemize}

\subsubsection{Cell functions}
\begin{itemize}
\item isTarget() - returns true if the cell is a target as specified in
the maze
\item Source() - returns true if the cell is the start point of the maze
\item get\_Loc() - returns the Integer ID of the cell
\end{itemize}

\section{Syntax summary\label{sec:Syntax-summary}}

The entire syntax is provided below. This section is intended for
the logical understanding of the language structure rather than an
exact copy of the language.\\



\subsection{Expressions}

The expression includes declaration statements as well.\\
\\
\textbf{expression:-}\\
\textbf{\hspace*{0.5cm}primary\_expression}\\
\textbf{\hspace*{0.5cm}lval\_expression}\\
\textbf{\hspace*{0.5cm}NOT expression}\\
\textbf{\hspace*{0.5cm}expression binop expression}\\
\textbf{\hspace*{0.5cm}functions}\\
\\
\textbf{primary-expression:-}\\
\textbf{\hspace*{0.5cm}identifier}\\
\textbf{\hspace*{0.5cm} literal }\\
\textbf{\hspace*{0.5cm} ( expression )}\\
\textbf{\hspace*{0.5cm}(CPos)}\\
\textbf{}\\
\textbf{lval\_expression:-}\\
\textbf{\hspace*{0.5cm}identifier := expression}\\
\textbf{\hspace*{0.5cm}datatype identifer := expression}\\
\textbf{\hspace*{0.5cm}datatype identifer}\\
\textbf{}\\
\textbf{datatype:-}\\
\textbf{\hspace*{0.5cm}Integer}\\
\textbf{\hspace*{0.5cm}Boolean}\\
\textbf{\hspace*{0.5cm}Cell}\\
\textbf{\hspace*{0.5cm}List<datatype>}\\
\textbf{}\\
\textbf{binop:-}\\


\begin{tabular}{|cccc|c|}
\hline 
 & Operators &  &  & Associativity\tabularnewline
\hline 
\hline 
\textasciicircum{} &  &  &  & Right\tabularnewline
\hline 
/ & {*} & \% &  & Left\tabularnewline
\hline 
> & < & >= & <= & Left\tabularnewline
\hline 
== & \textasciitilde{}= &  &  & Left\tabularnewline
\hline 
NOT &  &  &  & Right\tabularnewline
\hline 
AND &  &  &  & Left\tabularnewline
\hline 
OR &  &  &  & Left\tabularnewline
\hline 
:= &  &  &  & Right\tabularnewline
\hline 
\end{tabular}\\
\\
The binop table shows the binary operators in the decreasing order
of precedence (top - bottom) along with their associativity which
gives the fashion in which they are grouped together.\\
\\
\textbf{functions:-}\\
\textbf{\hspace*{0.5cm}list\_functions}\\
\textbf{\hspace*{0.5cm}cell\_functions}\\
\textbf{\hspace*{0.5cm}maze\_functions}\\
\textbf{\hspace*{0.5cm}lang\_functions}\\
\textbf{}\\
\textbf{list\_functions:-}\\
\textbf{\hspace*{0.5cm}identifier.add(expr)}\\
\textbf{\hspace*{0.5cm}identifier.remove()}\\
\textbf{\hspace*{0.5cm}identifier.isEmpty()}\\
\textbf{\hspace*{0.5cm}identifier.head()}\\
\textbf{\hspace*{0.5cm}identifier.next()}\\
\textbf{}\\
\textbf{cell\_functions:-}\\
\textbf{\hspace*{0.5cm}identifier.left()}\\
\textbf{\hspace*{0.5cm}identifier.right()}\\
\textbf{\hspace*{0.5cm}identifier.up()}\\
\textbf{\hspace*{0.5cm}identifier.down()}\\
\textbf{\hspace*{0.5cm}identifier.hasleft()}\\
\textbf{\hspace*{0.5cm}identifier.hasright()}\\
\textbf{\hspace*{0.5cm}identifier.hastop()}\\
\textbf{\hspace*{0.5cm}identifier.hasbottom()}\\
\textbf{\hspace*{0.5cm}identifier.isTarget()}\\
\textbf{}\\
\textbf{maze\_functions:-}\\
\textbf{\hspace*{0.5cm}Visit(identifier)}\\
\textbf{\hspace*{0.5cm}get\_Loc(identifier)}\\
\textbf{\hspace*{0.5cm}revert()}\\
\textbf{}\\
\textbf{lang\_functions:-}\\
\textbf{\hspace*{0.5cm}identifier(actual\_args\textsubscript{\textbf{opt}})}\\
\textbf{\hspace*{0.5cm}display()}\\
\textbf{\hspace*{0.5cm}print(identifier)}\\
\textbf{}\\
\textbf{actual\_args:-}\\
\textbf{\hspace*{0.5cm}primary\_expression}\\
\textbf{\hspace*{0.5cm}primary\_expression, actual\_args}\\
\textbf{}\\



\subsection{Statements}

Statements are logical sentences that can be formed by the language.
A compound statement is a group of statements occuring in a linear
fashion one after the other.\\
\textbf{compound-statement:-}\\
\textbf{\hspace*{0.5cm}\{statement-list\}}\\
\textbf{}\\
\textbf{statement-list:-}\\
\textbf{\hspace*{0.5cm}statement}\\
\textbf{\hspace*{0.5cm}statement statement-list}\\
\textbf{}\\
\textbf{statement:-}\\
\textbf{\hspace*{0.5cm}expression;}\\
\textbf{\hspace*{0.5cm}return expr;}\\
\textbf{\hspace*{0.5cm}\{ statement-list \}}\\
\textbf{\hspace*{0.5cm}if (expression) statement;}\\
\textbf{\hspace*{0.5cm}if (expression) statement else statement}\\
\textbf{\hspace*{0.5cm}exit;}\\
\textbf{}\\
\\
If the expression to 'if' does not evaluate to True or False, an error
will be thrown. 


\subsection{Program Definition\label{sub:Program-Definition}}

This subsection describes the structure of the program and functions
which are the biggest building blocks in aML. Every aML must have
one and only one main function through which the control passes to
the program. It must also have exactly one pre-processor directive
to load the maze. It can have an arbitrary number of functions though.
The program structure is defined below:-\\
\\
\textbf{program:-}\\
\textbf{\hspace*{0.5cm}empty\_program}\\
\textbf{\hspace*{0.5cm}pre-process program}\\
\textbf{\hspace*{0.5cm}func-def program}\\
\textbf{}\\
\textbf{empty-program:- }\\
\textbf{\hspace*{0.5cm}}\\
\textbf{pre-process:-}\\
\textbf{\hspace*{0.5cm}\#load-identifier}\\
\textbf{\hspace*{0.5cm}\#load-random}\\
\textbf{}\\
\textbf{func-def:-}\\
\textbf{\hspace*{0.5cm}main():void \{statement-list\}}\\
\textbf{\hspace*{0.5cm}identifier(formal-args\textsubscript{\textbf{opt}}):return-type\{statement-list\}}\\
\textbf{}\\
\textbf{formal-args\textsubscript{\textbf{opt}}:-}\\
\textbf{\hspace*{0.5cm}datatype identifier}\\
\textbf{\hspace*{0.5cm}datatype identifier,formal-args}\\
\textbf{}\\
\textbf{return-type:-}\\
\textbf{\hspace*{0.5cm}datatype}\\
\textbf{\hspace*{0.5cm}void}
\end{document}
